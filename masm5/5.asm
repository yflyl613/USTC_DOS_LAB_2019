DATA SEGMENT
    LEN DW 0
    OPINSATCK DW 0
    NUMBERFLAG DB 0
    SUFFIX DW 1024 DUP (?)
    TEN DB 10
    DISPLAYBUFFER DB 5 DUP (?)
DATA ENDS
STACK SEGMENT STACK
    DW 1024 DUP (?)
STACK ENDS
CODE SEGMENT
    ASSUME CS:CODE,DS:DATA,SS:STACK
START:
    MOV AX,DATA
    MOV DS,AX

    XOR DI,DI   ;SUFFIX STRING INDEX IN DI
    XOR BX,BX   ;ONE NUMBER IN BX
    XOR AX,AX
NEXTCHAR:
    MOV AH,01H
    INT 21H

    MOV AH,0
    CMP AL,0DH      ;'\n'
    JNZ NOTEND
    JMP READFINISH

NOTEND:
    INC LEN         ;INPUT CHAR IN AL
    CMP AX,'('
    JNZ NOTLB
    PUSH AX         ;'(' THEN PUSH
    INC OPINSATCK
    JMP NEXTCHAR
NOTLB:
    CMP AX,')'          ;')' THEN POP AND ADD TO SUFFIX UNTIL '('
    JNZ NOTRB
    CMP NUMBERFLAG,1    ;HAS NUMBER BEFORE THEN ADD NUBER TO SUFFIX
    JNZ NONUMBER
    MOV SUFFIX[DI],BX
    ADD DI,2
    MOV NUMBERFLAG,0
    XOR BX,BX
NONUMBER:
    POP DX
    DEC OPINSATCK
    CMP DX,'('
    JZ LBOUT
    MOV SUFFIX[DI],DX
    ADD DI,2
    JMP NONUMBER
LBOUT:
    JMP NEXTCHAR

NOTRB:
    CMP AX,'+'          ;'+' IF TOP IS '(' THEN PUSH ELSE POP AND ADD TO SUFFIX
    JNZ NOTPLUS
    CMP NUMBERFLAG,1    ;HAS NUMBER BEFORE THEN ADD NUBER TO SUFFIX
    JNZ NONUMBER1
    MOV SUFFIX[DI],BX
    ADD DI,2
    MOV NUMBERFLAG,0
    XOR BX,BX
NONUMBER1:
    CMP OPINSATCK,0     ;IF STACK IS EMPTY THEN JUST PUSH
    JZ STACKISEMPTY
    POP DX
    CMP DX,'('
    JNZ TOPNOTLB
    PUSH DX
STACKISEMPTY:
    PUSH AX
    INC OPINSATCK
    JMP NEXTCHAR
TOPNOTLB:
    MOV SUFFIX[DI],DX
    PUSH AX
    ADD DI,2
    JMP NEXTCHAR

NOTPLUS:
    CMP AX,'-'          ;'-' IF TOP IS '(' THEN PUSH ELSE POP AND ADD TO SUFFIX
    JNZ NOTMINUS
    CMP NUMBERFLAG,1    ;HAS NUMBER BEFORE THEN ADD NUBER TO SUFFIX
    JNZ NONUMBER2
    MOV SUFFIX[DI],BX
    ADD DI,2
    MOV NUMBERFLAG,0
    XOR BX,BX
NONUMBER2:
    CMP OPINSATCK,0     ;IF STACK IS EMPTY THEN JUST PUSH
    JZ STACKISEMPTY2
    POP DX
    CMP DX,'('
    JNZ TOPNOTLB2
    PUSH DX
STACKISEMPTY2:
    PUSH AX
    INC OPINSATCK
    JMP NEXTCHAR
TOPNOTLB2:
    MOV SUFFIX[DI],DX
    PUSH AX
    ADD DI,2
    JMP NEXTCHAR

NOTMINUS:
    MOV CX,AX           ;CALCULATE NUMBER IN BX
    SUB CX,30H          ;SET NUMBERFLAG
    MOV AX,10
    MUL BX
    MOV BX,AX
    ADD BX,CX
    MOV NUMBERFLAG,1
    JMP NEXTCHAR

READFINISH:
    CMP NUMBERFLAG,0    ;STILL HAS NUMBER IN BX THEN ADD TO SUFFIX 
    JZ POPOP
    MOV SUFFIX[DI],BX
    ADD DI,2
    MOV NUMBERFLAG,0
POPOP:                  ;IF STACK IS NOT EMPTY THEN POP AND ADD TO SUFFIX
    CMP OPINSATCK,0
    JZ SUFFIXREADY
    POP DX
    DEC OPINSATCK
    MOV SUFFIX[DI],DX
    ADD DI,2
    JMP READFINISH

SUFFIXREADY:
    XOR SI,SI           
    XOR BX,BX
    XOR AX,AX
AGAIN:
    MOV CX,SUFFIX[SI]   ;OP IN CX
    CMP CX,'+'
    JNZ NOTPLUSOP
    POP AX              ;'+' POP TWO OP AND ADD AND PUSH
    POP BX
    ADD BX,AX
    PUSH BX
    JMP NEXTOP
NOTPLUSOP:
    CMP CX,'-'
    JNZ NOTMINUSOP
    POP AX              ;'-' POP TWO OP AND AUB AND PUSH
    POP BX
    SUB BX,AX
    PUSH BX
    JMP NEXTOP
NOTMINUSOP:
    PUSH CX             ;PUSH NUMBER
NEXTOP:
    ADD SI,2
    CMP SI,DI
    JZ DISPLAY
    JMP AGAIN

DISPLAY:
    POP BX          ;ANS IN BX
    MOV BYTE PTR DISPLAYBUFFER,30H      ;data byte
    MOV BYTE PTR DISPLAYBUFFER[1],30H
    MOV BYTE PTR DISPLAYBUFFER[2],30H
    MOV BYTE PTR DISPLAYBUFFER[3],30H
    MOV BYTE PTR DISPLAYBUFFER[4],30H
    MOV DI,4
    CMP BX,0
    JGE NEXT
    MOV DL,'-'      ;IF NEG THEN DISPLAY '-'
    MOV AH,02H
    INT 21H
    NEG BX
NEXT:
    MOV AX,BX       ;ANS IN AX
NEXTROUND:
    CMP AX,9                                
    JLE FINISH
    DIV BYTE PTR TEN          ;change to deciaml ascii
    ADD BYTE PTR DISPLAYBUFFER[DI],AH
    MOV AH,00H
    DEC DI
    JMP NEXTROUND

FINISH:
    ADD DISPLAYBUFFER[DI],AL
    XOR SI,SI
SKIPZERO:
    MOV DL,DISPLAYBUFFER[SI]
    INC SI
    CMP DL,30H
    JZ SKIPZERO
SHOWDIGIT:
    MOV AH,02H
    INT 21H
    MOV DL,DISPLAYBUFFER[SI]
    INC SI
    CMP SI,6
    JZ EXIT
    JMP SHOWDIGIT

EXIT:
    MOV AX,4C00H
    INT 21H
CODE ENDS
END START